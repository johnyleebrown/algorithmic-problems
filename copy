	public class Solution2
	{
		public int[][] kClosest(int[][] points, int K) 
		{
			int n = points.length;
			int[][] x = new int[K][2];

			for (int i = 0; i < K; i++)
			{
				x[i] = points[i];
				swim(x, i);
			}

			for (int i = K; i < points.length; i++)
			{
				if (greater(x[0], points[i]))
				{
					x[0] = points[i];
					sink(x, 0, K);
				}
			}

			return x;
		}

		// min heap - using greater instead of less
		private void sink(int[][] a, int k, int n)
		{
			while (2 * k <= n)
			{
				int j = 2 * k;

				if (j + 1 < n && greater(a[j], a[j + 1]))
				{
					j++;
				}

				if (!greater(a[k], a[j]))
				{
					break;
				}

				exch(a, k, j);

				k = j;
			}
		}

		// moving element up, towards the start of the array
		private void swim(int[][] a, int k)
		{
			while (k > 1 && greater(a[k/2], a[k]))
			{
				exch(a, k, k/2);
				k /= 2;
			}
		}

		private boolean greater(int[] a, int[] b)
		{
			int distA = Math.abs(a[0]) * Math.abs(a[0]) + 
				Math.abs(a[1]) * Math.abs(a[1]);
			int distB = Math.abs(b[0]) * Math.abs(b[0]) + 
				Math.abs(b[1]) * Math.abs(b[1]);

			return distA > distB;
		}

		private void exch(int[][] a, int i, int j)
		{
			int[] temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}

}
